# config/config.example.yaml
# Template for go-mail-webhook-service application configuration.
# Copy this file to config/config.yaml and replace placeholder values with real ones.
#
# Notes:
# - The top-level structure is a single YAML object (one configuration).
# - Supported selector types: "subjectRegex", "bodyRegex", "attachmentNameRegex", "senderRegex", "recipientRegex"
# - Supported HTTP methods are standard HTTP verbs; when omitted, goback defaults:
#     - POST if a body or multipart is configured
#     - GET otherwise
#
# Placeholders (Go text/template):
# - Use {{ .SelectorName }} in callback values (headers/query/body/multipart.fields) to reference a selector's extracted value.
# - Selector names must be alphanumeric only (^[0-9A-Za-z]+$).
#
# Callback schema (goback.Config):
# - callback.headers: map of header key -> value (templated)
# - callback.query: map of query key -> value (templated)
# - callback.body: raw string body; build JSON yourself if desired (templated)
# - callback.multipart.fields: map of form field key -> value (templated)
# - callback.expectedStatus: optional list of acceptable status codes; when unset, defaults to treating 2xx/3xx as success in this service
# - callback.maxRetries: number of retry attempts on errors/unexpected status (0 = single attempt)
# - callback.backoff: delay between retries, K8s-style duration (e.g., "30s", "3m", "4d")
#
# Attachments behavior:
# - Top-level attachments.* controls forwarding email attachments as multipart file parts.
# - goback's multipart.files are assembled at runtime from incoming mail; YAML only configures fields.
# - When attachments.enabled is true and an email has attachments, they will be added as file parts
#   with field names "<fieldPrefix>_0", "<fieldPrefix>_1", ... honoring maxSize.
#
# Processing behavior:
# - processing.processedAction controls how an email is marked as processed after a successful webhook call.
#   Supported values:
#     - "markRead" (default): mark the email as read
#     - "delete": delete the email after successful processing (irreversible in Gmail)
#
# Selector behavior:
# - All selectors provided must match for an email to be processed. If any selector fails to match, the email is skipped.

# Comprehensive configuration demonstrating selectors and structured callback sections
logLevel: "info"

mailSelectors:
  # Extract numeric Order ID from the email subject
  - name: "OrderId"
    type: "subjectRegex"
    pattern: "Order ([0-9]+) confirmed"
    captureGroup: 1

  # Extract amount value from the email body
  - name: "Amount"
    type: "bodyRegex"
    pattern: "Total: \\$([0-9]+\\.[0-9]{2})"
    captureGroup: 1

  # Extract sender email address domain (e.g., captures "example.com" from "user@example.com")
  - name: "SenderDomain"
    type: "senderRegex"
    pattern: "@([^@]+)$"
    captureGroup: 1

  # Extract a number from an attachment file name like 'invoice-12345.pdf'
  - name: "FileNum"
    type: "attachmentNameRegex"
    pattern: "invoice-([0-9]+)\\.pdf"
    captureGroup: 1

# Outgoing webhook (goback.Config)
callback:
  # The webhook endpoint to call with extracted values
  # here we use host.docker.internal to access a service running on the host machine from inside the Docker container; adjust as needed for your environment
  url: "http://host.docker.internal:8080/api"
  # HTTP method (optional). If omitted and body/multipart is set, defaults to POST; otherwise GET.
  method: "POST"
  # Request timeout as a duration string, parsed by goback (supports k8s-style durations, e.g., "24s", "3m", "4d").
  timeout: "24s"
  # Number of retry attempts for the webhook. 0 = single attempt.
  maxRetries: 0

  # Headers as a map
  headers:
    X-Order-Id: "{{ .OrderId }}"
    Content-Type: "application/json"

  # Query parameters as a map
  query:
    fileNum: "{{ .FileNum }}"

  # Optional multipart form fields; files are added at runtime based on attachments.*
  # multipart:
  #   fields:
  #     note: "Processed order {{ .OrderId }}"

  # Raw body: build JSON yourself using placeholders if needed (ignored when multipart is set)
  body: |
    {
      "amount": "{{ .Amount }}",
      "senderDomain": "{{ .SenderDomain }}"
    }

# Forward attachments as multipart/form-data file parts (added to callback.multipart.files at runtime)
attachments:
  enabled: false
  fieldPrefix: "attachment"  # Parts will be named like "attachment_0", "attachment_1", ...
  maxSize: "0"               # "0" or empty means no per-attachment size limit

# Processing behavior: choose how to mark mails after successful processing
processing:
  # Supported values: "markRead" (default) or "delete"
  processedAction: "markRead"

# Minimal configuration (GET with query param)
# Uncomment below to use a minimal example instead of the comprehensive one
#
# mailSelectors:
#   # Capture a URL from the email body (full match)
#   - name: "Link"
#     type: "bodyRegex"
#     pattern: "https?://(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}([-a-zA-Z0-9()@:%_+.~#?&/=]*)"
#     captureGroup: 0   # 0 means use the entire match
#
# callback:
#   url: "https://api.example.com/collect"
#   # method omitted: will default to GET since no body/multipart is set
#   timeout: "10s"
#   maxRetries: 1
#   query:
#     url: "{{ .Link }}"